{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	//  "prefix": "log",
	//  "body": [
	//    "console.log('$1');",
	//    "$2"
	//  ],
	//  "description": "Log output to console"
	// }

  "1": {
  "prefix": "joy",
  "body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "      ",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
  },
  "2": {
	"prefix": "joy1",
	"body": [
	  "class node",
	  "{",
	  "    public:",
	  "       int val;",
	  "       node* next;",
	  "    node(int val)",
	  "    {",
	  "        this->val=val;",
	  "        this->next=NULL;",
	  "    }",
	  "};"
	],
	"description": ""
  },
  "3": {
	"prefix": "joy2",
	"body": [
	  "class node",
	  "{",
	  "public:",
	  "    int val;",
	  "    node *prev;",
	  "    node *next;",
	  "    node(int val)",
	  "    {",
	  "        this->val = val;",
	  "        this->prev = NULL;",
	  "        this->next = NULL;",
	  "    }",
	  "};"
	],
	"description": ""
  },
  "4": {
	"prefix": "joy3",
	"body": [
	  "class node",
	  "{",
	  "public:",
	  "    int val;",
	  "    node *left;",
	  "    node *right;",
	  "    node(int val)",
	  "    {",
	  "        this->val = val;",
	  "        this->left = NULL;",
	  "        this->right = NULL;",
	  "    }",
	  "};"
	],
	"description": ""
  },
  "5": {
  "prefix": "joy4",
  "body": [
    "void level_order(node*root)",
    "{",
    "    if(root==NULL)",
    "    {",
    "        return;",
    "    }",
    "    queue<node *> q;",
    "    q.push(root);",
    "    while(!q.empty())",
    "    {",
    "        node *p = q.front();",
    "        q.pop();",
    "",
    "        cout << p->val << \" \";",
    "",
    "        if(p->left)",
    "        {",
    "            q.push(p->left);",
    "        }",
    "        if(p->right)",
    "        {",
    "            q.push(p->right);",
    "        }",
    "    }",
    "}"
  ],
  "description": ""
},
"6": {
  "prefix": "pbds",
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "#include<ext/pb_ds/assoc_container.hpp>",
    "#include<ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "",
    "using namespace std;",
    "",
    "template <typename T> using pbds = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    "",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
},
  "7": {
  "prefix": "joy5",
  "body": [
    "",
    "node* input_tree()",
    "{",
    "    int val;",
    "    cin >> val;",
    "    node *root;",
    "    if(val==-1)",
    "    {",
    "        root = NULL;",
    "    }",
    "    else{",
    "        root=new node(val);",
    "    }",
    "    queue<node *> q;",
    "    if(root)",
    "    {",
    "        q.push(root);",
    "    }",
    "    while(!q.empty())",
    "    {",
    "        node *p = q.front();",
    "        q.pop();",
    "        int l, r;",
    "        cin >> l >> r;",
    "",
    "        node *myleft;",
    "        node *myright;",
    "",
    "        if(l==-1)",
    "        {",
    "            myleft = NULL;",
    "        }",
    "        else{",
    "            myleft = new node(l);",
    "        }",
    "",
    "        if(r==-1)",
    "        {",
    "            myright = NULL;",
    "        }",
    "        else{",
    "            myright= new node(r);",
    "        }",
    "",
    "        p->left = myleft;",
    "        p->right = myright;",
    "",
    "        if(p->left)",
    "        {",
    "            q.push(p->left);",
    "        }",
    "        if(p->right)",
    "        {",
    "            q.push(p->right);",
    "        }",
    "    }",
    "    return root;",
    "}",
    ""
  ],
  "description": ""
},
"": {
  "prefix": "segment tree",
  "body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    "",
    "const long long maxN = 1e5 + 9;",
    "long long a[maxN], t[4 * maxN];",
    "",
    "void build(long long n,long long b,long long e)",
    "{",
    "    if(b==e)",
    "    {",
    "        t[n] = a[b];",
    "        return;",
    "    }",
    "    long long mid = (b + e) / 2;         //     n",
    "    long long l = 2 * n;                 /*    / \\     */ ",
    "    long long r = 2 * n + 1;            //    l   r",
    "    build(l, b, mid);",
    "    build(r, mid + 1, e);",
    "    t[n] = t[l] + t[r];    // change this",
    "}",
    "",
    "void update(long long n,long long b,long long e,long long i,long long v)",
    "{",
    "    if(i<b || i>e)",
    "    {",
    "        return;",
    "    }",
    "    if(b==e)",
    "    {",
    "        t[n] = v;",
    "        return;",
    "    }",
    "    long long mid = (b + e) / 2;",
    "    long long l = 2 * n;",
    "    long long r = 2 * n + 1;",
    "    update(l, b, mid, i, v);",
    "    update(r, mid + 1, e, i, v);",
    "    t[n] = t[l] + t[r];   // change this",
    "}",
    "",
    "long long query(long long n,long long b,long long e,long long i,long long j)",
    "{",
    "    if(e<i || j<b)",
    "    {",
    "        return 0;         // return right value",
    "    }",
    "    if(b>=i && e<=j)",
    "    {",
    "        return t[n];",
    "    }",
    "    long long mid = (b + e) / 2;",
    "    long long l = 2 * n;",
    "    long long r = 2 * n + 1;",
    "    return query(l, b, mid, i, j) + query(r, mid + 1, e, i, j); // change this",
    "}",
    "",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "",
    "    long long n, m;",
    "    cin >> n >> m;",
    "    for (long long i = 1; i <= n;i++)",
    "    {",
    "        cin >> a[i];",
    "    }",
    "    build(1, 1, n);",
    "",
     "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
},

"Segment Tree Lazy": {
"prefix": "segment_tree_lazy",
"body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    "",
    "const long long maxN = 1e5 + 9;",
    "long long a[maxN], t[4 * maxN], lazy[4 * maxN];",
    "",
    "void build(long long n,long long b,long long e)",
    "{",
    "    lazy[n] = 0;     // change this",
    "    if(b==e)",
    "    {",
    "        t[n] = a[b];",
    "        return;",
    "    }",
    "    long long mid = (b + e) / 2;         //     n",
    "    long long l = 2 * n;                 /*    / \\     */", 
    "    long long r = 2 * n + 1;            //    l   r",
    "    build(l, b, mid);",
    "    build(r, mid + 1, e);",
    "    t[n] = t[l] + t[r];    // change this",
    "}",
    "",
    "void push(long long n,long long b,long long e)",
    "{",
    "    if(lazy[n] == 0)   // change this",
    "    {",
    "        return;",
    "    }",
    "    t[n] += (e - b + 1) * lazy[n];",
    "    if(b != e)",
    "    {",
    "        long long l = 2 * n;",
    "        long long r = 2 * n + 1;",
    "        lazy[l] += lazy[n];",
    "        lazy[r] += lazy[n];",
    "    }",
    "    lazy[n] = 0;       // change this",
    "}",
    "",
    "void update(long long n,long long b,long long e,long long i,long long j,long long v)",
    "{",
    "    push(n, b, e);",
    "    if(e<i || j<b)",
    "    {",
    "        return;",
    "    }",
    "    if(b>=i && e<=j)",
    "    {",
    "        lazy[n] += v;     // set correct propagation",
    "        push(n, b, e);",
    "        return;",
    "    }",
    "    long long mid = (b + e) / 2;         //     n",
    "    long long l = 2 * n;                 /*    / \\     */", 
    "    long long r = 2 * n + 1;            //    l   r",
    "    update(l, b, mid, i, j, v);",
    "    update(r, mid + 1, e, i, j, v);",
    "    t[n] = t[l] + t[r];   // change this",
    "}",
    "",
    "long long query(long long n,long long b,long long e,long long i,long long j)",
    "{",
    "    push(n, b, e);",
    "    if(e<i || j<b)",
    "    {",
    "        return 0;         // return right value",
    "    }",
    "    if(b>=i && e<=j)",
    "    {",
    "        return t[n];",
    "    }",
    "    long long mid = (b + e) / 2;         //     n",
    "    long long l = 2 * n;                 /*    / \\     */", 
    "    long long r = 2 * n + 1;            //    l   r",
    "    return query(l, b, mid, i, j) + query(r, mid + 1, e, i, j); // change this",
    "}",
    "",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "",
    "    long long n, m;",
    "    cin >> n >> m;",
    "    for (long long i = 1; i <= n;i++)",
    "    {",
    "        a[i] = 0;",
    "    }",
    "    build(1, 1, n);",
    "",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
},
"dsu": {
  "prefix": "dsu",
  "body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    "struct DSU",
    "{",
    "    vector<long long> par, rnk, siz;",
    "    long long c;",
    "    DSU(long long n) : par(n + 1, 1), rnk(n + 1, 0), siz(n + 1, 1), c(n)",
    "    {",
    "        for (long long i = 1; i <= n;i++)",
    "        {",
    "            par[i] = i;",
    "        }",
    "    }",
    "    long long find(long long i)",
    "    {",
    "        return (par[i] == i ? i : (par[i] = find(par[i])));",
    "    }",
    "    bool same(long long u,long long v)",
    "    {",
    "        return find(u) == find(v);",
    "    }",
    "    long long getsize(long long u)",
    "    {",
    "        return siz[find(u)];",
    "    }",
    "    long long cnt()",
    "    {",
    "        return c;",
    "    }",
    "    void merge(long long u,long long v)",
    "    {",
    "        if((u=find(u))==(v=find(v)))",
    "        {",
    "            return;",
    "        }",
    "        else{",
    "            c--;",
    "        }",
    "        if(rnk[u]>rnk[v])",
    "        {",
    "            swap(u, v);",
    "        }",
    "        else if(rnk[u]==rnk[v])",
    "        {",
    "            rnk[v]++;",
    "        }",
    "        par[u] = par[v];",
    "        siz[v] += siz[u];",
    "    }",
    "};",
    "",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "      ",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
}
}
