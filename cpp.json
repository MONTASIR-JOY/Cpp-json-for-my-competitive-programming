{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	//  "prefix": "log",
	//  "body": [
	//    "console.log('$1');",
	//    "$2"
	//  ],
	//  "description": "Log output to console"
	// }

  "1": {
  "prefix": "joy",
  "body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "      ",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
  },
  "2": {
	"prefix": "joy1",
	"body": [
	  "class node",
	  "{",
	  "    public:",
	  "       int val;",
	  "       node* next;",
	  "    node(int val)",
	  "    {",
	  "        this->val=val;",
	  "        this->next=NULL;",
	  "    }",
	  "};"
	],
	"description": ""
  },
  "3": {
	"prefix": "joy2",
	"body": [
	  "class node",
	  "{",
	  "public:",
	  "    int val;",
	  "    node *prev;",
	  "    node *next;",
	  "    node(int val)",
	  "    {",
	  "        this->val = val;",
	  "        this->prev = NULL;",
	  "        this->next = NULL;",
	  "    }",
	  "};"
	],
	"description": ""
  },
  "4": {
	"prefix": "joy3",
	"body": [
	  "class node",
	  "{",
	  "public:",
	  "    int val;",
	  "    node *left;",
	  "    node *right;",
	  "    node(int val)",
	  "    {",
	  "        this->val = val;",
	  "        this->left = NULL;",
	  "        this->right = NULL;",
	  "    }",
	  "};"
	],
	"description": ""
  },
  "5": {
  "prefix": "joy4",
  "body": [
    "void level_order(node*root)",
    "{",
    "    if(root==NULL)",
    "    {",
    "        return;",
    "    }",
    "    queue<node *> q;",
    "    q.push(root);",
    "    while(!q.empty())",
    "    {",
    "        node *p = q.front();",
    "        q.pop();",
    "",
    "        cout << p->val << \" \";",
    "",
    "        if(p->left)",
    "        {",
    "            q.push(p->left);",
    "        }",
    "        if(p->right)",
    "        {",
    "            q.push(p->right);",
    "        }",
    "    }",
    "}"
  ],
  "description": ""
},
"6": {
  "prefix": "pbds",
  "body": [
    "#include <bits/stdc++.h>",
    "",
    "#include<ext/pb_ds/assoc_container.hpp>",
    "#include<ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "",
    "using namespace std;",
    "",
    "template <typename T> using pbds = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    "// find by order, order of key",
    "",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
},
  "7": {
  "prefix": "joy5",
  "body": [
    "",
    "node* input_tree()",
    "{",
    "    int val;",
    "    cin >> val;",
    "    node *root;",
    "    if(val==-1)",
    "    {",
    "        root = NULL;",
    "    }",
    "    else{",
    "        root=new node(val);",
    "    }",
    "    queue<node *> q;",
    "    if(root)",
    "    {",
    "        q.push(root);",
    "    }",
    "    while(!q.empty())",
    "    {",
    "        node *p = q.front();",
    "        q.pop();",
    "        int l, r;",
    "        cin >> l >> r;",
    "",
    "        node *myleft;",
    "        node *myright;",
    "",
    "        if(l==-1)",
    "        {",
    "            myleft = NULL;",
    "        }",
    "        else{",
    "            myleft = new node(l);",
    "        }",
    "",
    "        if(r==-1)",
    "        {",
    "            myright = NULL;",
    "        }",
    "        else{",
    "            myright= new node(r);",
    "        }",
    "",
    "        p->left = myleft;",
    "        p->right = myright;",
    "",
    "        if(p->left)",
    "        {",
    "            q.push(p->left);",
    "        }",
    "        if(p->right)",
    "        {",
    "            q.push(p->right);",
    "        }",
    "    }",
    "    return root;",
    "}",
    ""
  ],
  "description": ""
},
"": {
  "prefix": "segment tree",
  "body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    "",
    "const long long maxN = 1e5 + 9;",
    "long long a[maxN], t[4 * maxN];",
    "",
    "void build(long long n,long long b,long long e)",
    "{",
    "    if(b==e)",
    "    {",
    "        t[n] = a[b];",
    "        return;",
    "    }",
    "    long long mid = (b + e) / 2;         //     n",
    "    long long l = 2 * n;                 /*    / \\     */ ",
    "    long long r = 2 * n + 1;            //    l   r",
    "    build(l, b, mid);",
    "    build(r, mid + 1, e);",
    "    t[n] = t[l] + t[r];    // change this",
    "}",
    "",
    "void update(long long n,long long b,long long e,long long i,long long v)",
    "{",
    "    if(i<b || i>e)",
    "    {",
    "        return;",
    "    }",
    "    if(b==e)",
    "    {",
    "        t[n] = v;",
    "        return;",
    "    }",
    "    long long mid = (b + e) / 2;",
    "    long long l = 2 * n;",
    "    long long r = 2 * n + 1;",
    "    update(l, b, mid, i, v);",
    "    update(r, mid + 1, e, i, v);",
    "    t[n] = t[l] + t[r];   // change this",
    "}",
    "",
    "long long query(long long n,long long b,long long e,long long i,long long j)",
    "{",
    "    if(e<i || j<b)",
    "    {",
    "        return 0;         // return right value",
    "    }",
    "    if(b>=i && e<=j)",
    "    {",
    "        return t[n];",
    "    }",
    "    long long mid = (b + e) / 2;",
    "    long long l = 2 * n;",
    "    long long r = 2 * n + 1;",
    "    return query(l, b, mid, i, j) + query(r, mid + 1, e, i, j); // change this",
    "}",
    "",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "",
    "    long long n, m;",
    "    cin >> n >> m;",
    "    for (long long i = 1; i <= n;i++)",
    "    {",
    "        cin >> a[i];",
    "    }",
    "    build(1, 1, n);",
    "",
     "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
},

"Segment Tree Lazy": {
"prefix": "segment_tree_lazy",
"body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    "",
    "const long long maxN = 1e5 + 9;",
    "long long a[maxN], t[4 * maxN], lazy[4 * maxN];",
    "",
    "void build(long long n,long long b,long long e)",
    "{",
    "    lazy[n] = 0;     // change this",
    "    if(b==e)",
    "    {",
    "        t[n] = a[b];",
    "        return;",
    "    }",
    "    long long mid = (b + e) / 2;         //     n",
    "    long long l = 2 * n;                 /*    / \\     */", 
    "    long long r = 2 * n + 1;            //    l   r",
    "    build(l, b, mid);",
    "    build(r, mid + 1, e);",
    "    t[n] = t[l] + t[r];    // change this",
    "}",
    "",
    "void push(long long n,long long b,long long e)",
    "{",
    "    if(lazy[n] == 0)   // change this",
    "    {",
    "        return;",
    "    }",
    "    t[n] += (e - b + 1) * lazy[n];",
    "    if(b != e)",
    "    {",
    "        long long l = 2 * n;",
    "        long long r = 2 * n + 1;",
    "        lazy[l] += lazy[n];",
    "        lazy[r] += lazy[n];",
    "    }",
    "    lazy[n] = 0;       // change this",
    "}",
    "",
    "void update(long long n,long long b,long long e,long long i,long long j,long long v)",
    "{",
    "    push(n, b, e);",
    "    if(e<i || j<b)",
    "    {",
    "        return;",
    "    }",
    "    if(b>=i && e<=j)",
    "    {",
    "        lazy[n] += v;     // set correct propagation",
    "        push(n, b, e);",
    "        return;",
    "    }",
    "    long long mid = (b + e) / 2;         //     n",
    "    long long l = 2 * n;                 /*    / \\     */", 
    "    long long r = 2 * n + 1;            //    l   r",
    "    update(l, b, mid, i, j, v);",
    "    update(r, mid + 1, e, i, j, v);",
    "    t[n] = t[l] + t[r];   // change this",
    "}",
    "",
    "long long query(long long n,long long b,long long e,long long i,long long j)",
    "{",
    "    push(n, b, e);",
    "    if(e<i || j<b)",
    "    {",
    "        return 0;         // return right value",
    "    }",
    "    if(b>=i && e<=j)",
    "    {",
    "        return t[n];",
    "    }",
    "    long long mid = (b + e) / 2;         //     n",
    "    long long l = 2 * n;                 /*    / \\     */", 
    "    long long r = 2 * n + 1;            //    l   r",
    "    return query(l, b, mid, i, j) + query(r, mid + 1, e, i, j); // change this",
    "}",
    "",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "",
    "    long long n, m;",
    "    cin >> n >> m;",
    "    for (long long i = 1; i <= n;i++)",
    "    {",
    "        a[i] = 0;",
    "    }",
    "    build(1, 1, n);",
    "",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
},
"dsu": {
  "prefix": "dsu",
  "body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    "struct DSU",
    "{",
    "    vector<long long> par, rnk, siz;",
    "    long long c;",
    "    DSU(long long n) : par(n + 1, 1), rnk(n + 1, 0), siz(n + 1, 1), c(n)",
    "    {",
    "        for (long long i = 1; i <= n;i++)",
    "        {",
    "            par[i] = i;",
    "        }",
    "    }",
    "    long long find(long long i)",
    "    {",
    "        return (par[i] == i ? i : (par[i] = find(par[i])));",
    "    }",
    "    bool same(long long u,long long v)",
    "    {",
    "        return find(u) == find(v);",
    "    }",
    "    long long getsize(long long u)",
    "    {",
    "        return siz[find(u)];",
    "    }",
    "    long long cnt()",
    "    {",
    "        return c;",
    "    }",
    "    void merge(long long u,long long v)",
    "    {",
    "        if((u=find(u))==(v=find(v)))",
    "        {",
    "            return;",
    "        }",
    "        else{",
    "            c--;",
    "        }",
    "        if(rnk[u]>rnk[v])",
    "        {",
    "            swap(u, v);",
    "        }",
    "        else if(rnk[u]==rnk[v])",
    "        {",
    "            rnk[v]++;",
    "        }",
    "        par[u] = par[v];",
    "        siz[v] += siz[u];",
    "    }",
    "};",
    "",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    "      ",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
},
"hashing": {
  "prefix": "hashing",
  "body": [
    "#include<bits/stdc++.h>",
    "using namespace std;",
    " ",
    "const long long p1 = 137, mod1 = 127657753, p2 = 277, mod2 = 987654319;",
    "const long long N = 1e6 + 9;",
    " ",
    "long long power(long long x, long long n, long long MOD)",
    "{",
    "    long long ans = 1 % MOD;",
    "    while(n>0)",
    "    {",
    "        if(n&1)",
    "        {",
    "            ans = 1LL * ans * x % MOD;",
    "        }",
    "        x = 1LL * x * x % MOD;",
    "        n >>= 1;",
    "    }",
    "    return ans;",
    "}",
    " ",
    "pair<long long, long long> pw[N], ipw[N];",
    " ",
    "void prec()",
    "{",
    "    pw[0] = {1, 1};",
    "    for (long long i = 1; i < N; i++)",
    "    {",
    "        pw[i].first = 1LL * pw[i-1].first * p1 % mod1;",
    "        pw[i].second = 1LL * pw[i-1].second * p2 % mod2;",
    "    }",
    "    long long ip1 = power(p1, mod1 - 2, mod1);",
    "    long long ip2 = power(p2, mod2 - 2, mod2);",
    "    ipw[0] = {1, 1};",
    "    for (long long i = 1; i < N; i++)",
    "    {",
    "        ipw[i].first = 1LL * ipw[i-1].first * ip1 % mod1;",
    "        ipw[i].second = 1LL * ipw[i-1].second * ip2 % mod2;",
    "    }",
    "}",
    " ",
    "pair<long long, long long> string_hash(string s)",
    "{",
    "    long long n = s.size();",
    "    pair<long long, long long> hs({0, 0});",
    "    for (long long i = 0; i < n; i++)",
    "    {",
    "        hs.first = (hs.first % mod1 + 1LL * s[i] * pw[i].first % mod1) % mod1;",
    "        hs.second = (hs.second % mod2 + 1LL * s[i] * pw[i].second % mod2) % mod2;",
    "    }",
    "    return hs;",
    "}",
    " ",
    "pair<long long, long long> pref[N];",
    "void build(string s)",
    "{",
    "    long long n = s.size();",
    "    for (long long i = 0; i < n; i++)",
    "    {",
    "        pref[i].first = 1LL * s[i] * pw[i].first % mod1;",
    "        if(i) pref[i].first = (pref[i].first + pref[i-1].first) % mod1;",
    "        pref[i].second = 1LL * s[i] * pw[i].second % mod2;",
    "        if(i) pref[i].second = (pref[i].second + pref[i-1].second) % mod2;",
    "    }",
    "}",
    " ",
    "pair<long long, long long> get_hash(long long i, long long j)",
    "{",
    "    pair<long long, long long> hs({0, 0});",
    "    hs.first = pref[j].first;",
    "    if(i) hs.first = (hs.first - pref[i-1].first + mod1) % mod1;",
    "    hs.first = 1LL * hs.first * ipw[i].first % mod1;",
    " ",
    "    hs.second = pref[j].second;",
    "    if(i) hs.second = (hs.second - pref[i-1].second + mod2) % mod2;",
    "    hs.second = 1LL * hs.second * ipw[i].second % mod2;",
    " ",
    "    return hs;",
    "}",
    " ",
    "int main()",
    "{",
    "    ios::sync_with_stdio(false);",
    "    cin.tie(nullptr);",
    " ",
    "    prec();",
    "    $0",
    "    return 0;",
    "}"
  ],
  "description": ""
},
"sieve": {
  "prefix": "sieve",
  "body": [
    "const long long mxn = 1e7 + 9;",
    "vector<long long> primes;",
    "vector<bool> isPrime(mxn, true);",
    "",
    "void sieve()",
    "{",
    "    isPrime[0] = isPrime[1] = false;",
    "    primes.push_back(2);",
    "",
    "    for (long long i = 4; i < mxn;i+=2)",
    "    {",
    "        isPrime[i] = false;",
    "    }",
    "",
    "    for (long long i = 3; i * i < mxn;i+=2)",
    "    {",
    "        if(isPrime[i])",
    "        {",
    "            for (long long j = i * i; j < mxn;j+=2*i)",
    "            {",
    "                isPrime[j] = false;",
    "            }",
    "        }",
    "    }",
    "",
    "    for (long long i = 3; i < mxn;i+=2)",
    "    {",
    "        if(isPrime[i])",
    "        {",
    "            primes.push_back(i);",
    "        }",
    "    }",
    "}"
      ,
  ],
  "description": ""
}
}
